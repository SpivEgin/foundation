<!doctype html>
<html>
<head lang="en">
    <meta charset="utf-8">
    <title>Discount Editor</title>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>

    <script type="text/javascript">

        function pathToArray(path, separator) {
            path = path || [];
            separator = separator || "/";

            if (Array.isArray(path)) {
                return path;
            }

            if (typeof path != "string") {
                return path;
            }

            return path.replace(new RegExp("^[" + separator + "]+"), "")
                    .replace(new RegExp("[" + separator + "]+$"), "")
                    .split(separator);
        }

        function pathGet(subject, path, lastOne) {
            var result = [];

            /* params validation */
            if (typeof subject != "object") {
                return result;
            }

            path = this.pathToArray(path);
            if (path.length == 0) {
                return result;
            }

            lastOne = lastOne || false;

            /* path extraction */
            if (path[0] in subject) {
                result.push(subject[path[0]]);
            } else {
                return result;
            }

            if (path.length > 1) {
                result = result.concat(pathGet(subject[path[0]], path.slice(1), false));
            }

            /* single value result */
            if (lastOne) {
                if (result.length > 0) {
                    return result[result.length-1];
                }
                return undefined;
            }

            return result;
        }

        function pathSet(subject, path, value) {
            path = this.pathToArray(path);
            var values = pathGet(subject, path, false);

            for(var i = 0; i < path.length; i++) {

                if (i == path.length-1) {
                    values[i] = value;
                } else if (values[i] == undefined || typeof values[i] != "object") {
                    values[i] = {};
                } else {
                    continue;
                }

                if (i > 0) {
                    subject = values[i-1];
                }
                subject[path[i]] = values[i];
            }
        }

        var module = angular.module("DiscountEditor", []);

        module.directive('template', ['$compile', '$controller', '$rootScope', function ($compile, $controller) {
            var storedTemplates = {};
            return {
                restrict: 'EA',
                scope: false,
                compile: function (element, attributes) {
                    var templateIsTag = false;
                    var templateName = undefined;
                    var templateAttributes = {};
                    var templateController = undefined;
                    var templateWatchExpr = undefined;

                    if (element[0].tagName.toLowerCase() == this.name.toLowerCase()) {
                        templateIsTag = true;
                    }

                    /* (1) template attributes filtering */

                    if (templateIsTag) {
                        /* directive usage as a tag - all attributes related to directive */
                        for (var tagAttribute in attributes.$attr) {
                            if (!attributes.$attr.hasOwnProperty(tagAttribute)) {
                                continue;
                            }

                            var tagAttrName = tagAttribute.replace(/^(data-|x-)/, '');
                            templateAttributes[tagAttrName] = attributes[tagAttribute];
                        }

                    } else {
                        /* directive usage as an attribute - attribute prefix filtering */
                        var templatePrefix = 'tp';

                        /* template prefix attribute lookup */
                        var prefixAttributes = ['template', 'data-template', 'x-template'];
                        for(var prefixIdx in prefixAttributes) {
                            if (!prefixAttributes.hasOwnProperty(prefixIdx)) { continue; }
                            var prefixAttribute = prefixAttributes[prefixIdx];

                            if (prefixAttribute in attributes.$attr) {
                                if (attributes[prefixAttribute] != '') {
                                    templatePrefix = attributes[prefixAttribute];
                                }

                                delete attributes.$attr[prefixAttribute];
                                element.removeAttr(prefixAttribute);
                            }
                        }

                        /* grabbing template related attributes by prefix */
                        for (var attribute in attributes.$attr) {
                            if (!attributes.$attr.hasOwnProperty(attribute)) { continue; }

                            /* truncating possible prefixes */
                            var attr = attribute.replace(/^(data-|x-)/, '');

                            /* grabbing template related attributes and removing them from element */
                            if (attr.slice(0, templatePrefix.length) == templatePrefix) {
                                attr = attr.slice(templatePrefix.length);
                                attr = attr.slice(0, 1).toLowerCase() + attr.slice(1);

                                templateAttributes[attr] = attributes[attribute];
                                delete attributes.$attr[attribute];
                                element.removeAttr(attribute);
                            }
                        }
                    }

                    /* (2) template directive attributes handling */

                    /* template 'set' attribute handler */
                    if (templateAttributes.hasOwnProperty('set')) {
                        var saveName = templateAttributes['set'];
                        delete templateAttributes['set'];

                        /* angular scope and $compile operations requires HTML element to bind */
                        if (templateIsTag) {
                            storedTemplates[saveName] = '<span>' + element.html() + '</span>';
                        } else {
                            storedTemplates[saveName] = element[0].outerHTML;
                        }
                    }

                    /* template 'get' attribute handler */
                    if (templateAttributes.hasOwnProperty('get')) {
                        templateName = templateAttributes['get'];
                        delete templateAttributes['get']
                    }

                    /* template 'controller' attribute handler */
                    if (templateAttributes.hasOwnProperty('controller')) {
                        templateController = templateAttributes['controller'];
                        delete templateAttributes['controller']
                    }

                    /* template 'watch' attribute handler */
                    if (templateAttributes.hasOwnProperty('watch')) {
                        templateWatchExpr = templateAttributes['watch'];
                        delete templateAttributes['watch']
                    }

                    /* (3) directive element replacement */

                    /* directive link function */
                    return function (scope, element, attributes) {
                        var directiveScope = scope;
                        var directiveResult = '';

                        if (templateName != undefined && templateName != '') {
                            /* looking for a stored template HTML */
                            var templateHTML = '';
                            if (templateName in storedTemplates) {
                                templateHTML = storedTemplates[templateName];
                            }

                            /* taking subject to which new scope will be applied */
                            var templateElement = angular.element();
                            if (templateIsTag) {
                                if (templateHTML != '') {
                                    templateElement = angular.element(templateHTML)
                                }
                            } else {
                                templateElement = element.append(templateHTML);
                            }

                            /* making template scope and copying rest of attributes into */
                            var templateScope = directiveScope.$new(false, directiveScope);
                            for (var tplAttribute in templateAttributes) {
                                if (!templateAttributes.hasOwnProperty(tplAttribute)) { continue; }

                                var value = templateAttributes[tplAttribute];
                                templateScope[tplAttribute] = value;

                                if (value in directiveScope) {
                                    templateScope[tplAttribute] = directiveScope[value];
                                } else {
                                    if (/^\s*\{\{/.test(value)) {
                                        try {
                                            value = value.replace(/^\s*\{\{\s*/, "").replace(/\s*\}\}\s*$/, "");
                                            value = directiveScope.$eval(value);
                                        } catch (e) {
                                            console.log(e);
                                        }
                                    }
                                    templateScope[tplAttribute] = value;
                                }
                            }

                            /* binding template scope to template element */

                            directiveResult = $compile(templateElement)(templateScope);

                            /* assigning watchers if specified */
                            if (templateWatchExpr != undefined) {
                                templateScope.$watch(
                                        /* watch the expression for changes */
                                        function (scope) {
                                            return scope.$eval(templateWatchExpr);
                                        },
                                        /* element re-creation action on value changed */
                                        function (value) {
                                            directiveResult = $compile(templateElement)(templateScope);
                                            element.replaceWith(directiveResult);
                                            element = directiveResult;
                                        }
                                );
                            }
                        }

                        /* replacing template directive element with appropriate result */
                        element.replaceWith(directiveResult);
                        element = directiveResult;

                        /* controller binding */
                        if (templateController != undefined && templateController != '') {
                            $controller(templateController, {'$scope': templateScope, '$element': directiveResult});
                        }
                    }
                }}
        }]);

        module.service("$composer", ["$http", "$q", function ($http, $q) {
            var $composer = {
                API_SERVER_URL: "http://localhost:3000",

                ARRAY_PREFIX: "[]",

                UNIT_PREFIX: "*",
                UNIT_ARG_PREFIX: "@",
                UNIT_OUT_PREFIX: "#",

                basic: ["string", "int", "float", "boolean", "array", "object"],
                types: {},
                units: {},
                aliases: {},

                isBasic: function (typeName) {
                    return $composer.basic.indexOf(typeName) > 0;
                },

                isUnit: function (typeName) {
                    return typeName.indexOf($composer.UNIT_PREFIX) == 0;
                },

                isAny: function (typeName) {
                    return typeName == "any" || typeName == "*";
                },

                isArray: function (typeName) {
                    typeName = typeName.toString();
                    return typeName.indexOf($composer.ARRAY_PREFIX) == 0 || typeName == "array";
                },

                arrayType: function (typeName) {
                    typeName = typeName.toString();
                    return typeName.slice($composer.ARRAY_PREFIX.length);
                },

                alias: function(typeName) {
                    if (typeName in $composer.alias) {
                        return $composer.alias[typeName];
                    }
                    return typeName;
                },

                type: function (typeName) {
                    if (typeName in $composer.types) {
                        return $q.when($composer.types[typeName]);
                    }

                    return $http({
                        url: $composer.API_SERVER_URL + "/composer/type/" + typeName,
                        method: "GET"
                    }).then(function (response) {

                        if (response.data.error != null) {
                            alert(response + ":" + response.data.error.message);
                            return null;
                        }

                        if (typeName in response.data.result) {
                            $composer.types[typeName] = response.data.result[typeName];
                            return $composer.types[typeName];
                        }

                        return null;
                    });
                },

                unit: function (unitName) {
                    if (unitName in $composer.units) {
                        return $composer.units[unitName];
                    }

                    return $http({
                        url: $composer.API_SERVER_URL + "composer/unit/" + unitName,
                        method: "GET"
                    }).then(function (response) {
                        if (response.data.error != null) {
                            alert(response.data.error.message);
                            return null;
                        }
                        $composer.units[unitName] = response.data.result;
                    });
                }
            };
            return $composer;
        }]);

        module.controller("ComposeElement", ["$scope", "$q", "$composer", function (ComposeElement, $q, $composer) {
            
            var self = ComposeElement;        /* shorthand scope alias*/

            ComposeElement.self = self;       /* scope self reference */

            ComposeElement.isReady = false;   /* flag indicates that element is ready for render */
            ComposeElement.isBasic = true;    /* flag indicates that element is basic JS type */
            ComposeElement.isUnit = false;    /* flag indicates that element is Unit and not Type */

            ComposeElement.value = null;      /* value of current element */
            ComposeElement.type = undefined;  /* element type (Composer type) */
            ComposeElement.desc = "";         /* type description (Composer type) */
            ComposeElement.label = "";        /* type label (Composer type) */

            ComposeElement.path = [];         /* path to current element within json */
            ComposeElement.root = undefined;  /* reference to root ComposeElement (scope) */
            ComposeElement.json = undefined;  /* reference to root value (object) */
            ComposeElement.tree = undefined;  /* copy of json but with ComposeElement values (only in root) */

            ComposeElement.info = {};         /* sub-element types information (Composer types) */
            ComposeElement.children = {};     /* prepared input parameters for sub-elements */

            /* Scope initialization routines */
            ComposeElement.init = function(inputData) {
                self.isReady = false;

                /* Element initialization with given data values */
                inputData = inputData || self.data || {};

                for (var key in inputData) {
                    if (inputData.hasOwnProperty(key)) {
                        self[key] = inputData[key];
                    }
                }

                /* Element parameters validation */
                self.path = pathToArray(self.path);

                if (self.value == undefined) {
                    self.value = {};
                }

                if (self.type == undefined || typeof self.type != "string" || self.type == "") {
                    self.type = typeof self.value;
                }

                if (self.path.length == 0) {
                    self.json = self.value;
                    self.root = self;
                }

                /* Composer type resolution */
                if (!$composer.isBasic(self.type)) {
                    self.isBasic = false;
                    if ($composer.isUnit(self.type)) {
                        self.isUnit = true;
                        self.info = $composer.unit(self.type);
                    } else {
                        self.info = $composer.type(self.type);
                    }
                }

                $q.when(self.info).then(function (info) {
                    self.info = info;

                    for (var item in self.value) {
                        if (!self.value.hasOwnProperty(item)) {
                            continue;
                        }

                        if (self.info[item] == undefined) {
                            continue;
                        }

                        self.children[item] = {
                            path:  self.path.concat(item),
                            value: self.value[item],

                            root:  self.root,
                            json:  self.json,

                            type:  self.info[item].type,
                            desc:  self.info[item].desc,
                            label: self.info[item].label
                        };
                    }

                    self.isReady = true;
                });
            };

            ComposeElement.getEditorData = function(event) {
                return {
                    path: self.path
                }
            };

            ComposeElement.jsType = function(event) {
                return typeof self.value;
            };

            ComposeElement.childValue = function(key) {
                return pathGet(this.json, self.path.concat(key), true);
            };

            ComposeElement.canEdit = function() {
                return self != self.root;
            };

            ComposeElement.editItem = function() {
                return self != self.root;
            };

            ComposeElement.hasChildren = function() {
                return Object.keys(self.children).length > 0;
            };

            ComposeElement.init(self.data);
        }]);

        module.controller("ComposeEditor", ["$scope", "$q", "$composer", function (ComposeEditor) {

            var self = ComposeEditor;         /* shorthand scope alias*/

            ComposeEditor.self = self;        /* scope self reference */

            ComposeEditor.path = [];          /* current editing element path within json */
            ComposeEditor.json = undefined;   /* destination json */

            ComposeEditor.info = {};          /* sub-element types information (Composer types) */
            ComposeEditor.custom = false;     /* flag indicates that custom key is allowed */

            ComposeEditor.key = undefined;    /* current element key */
            ComposeEditor.type = undefined;   /* current element type */
            ComposeEditor.value = undefined;  /* current element value */

            /* Scope initialization routines */
            ComposeEditor.init = function(inputData) {
                /* Given params extraction */
                inputData = inputData || {};

                for (var key in inputData) {
                    if (inputData.hasOwnProperty(key)) {
                        self[key] = inputData[key];
                    }
                }
            };
            ComposeEditor.getTypes = function() {
                return [];
            };

            ComposeEditor.apply = function($event) {

            };

            ComposeEditor.cancel = function($event) {

            };
        }]);
        
        module.controller("RootController", ["$scope", function (RootController) {
            RootController.data = {
                value: {'visitor': {'first_name': 'test', 'last_name': '123'}},
                type: "DiscountRule"
            }
        }]);
    </script>

    <style>
        .container {
            padding: 0px 5px 0px 0px;
            background-color: #f3f6fa;
            background-image: repeating-linear-gradient(180deg, #d9edf7, #d9edf7 30px, #f5f5f5 30px, white 60px);
        }

        .compose-element {
            list-style: none;
            margin: 0;
            padding-left: 20px;
        }

        .compose-item-line {
            height: 30px;
            line-height: 30px;
        }

        .compose-item-line button {
            float: right;
            box-sizing: border-box;
            height: 30px;
            line-height: 26px;
            border-color: transparent;
            background-color: transparent;
        }

        .compose-item-line input {
            width: 100px;
            border: none;
            display: inline;
            height: 30px;
            padding: 5px;
            background-color: transparent;
        }
    </style>
</head>

<body ng-app="DiscountEditor">

<!-- template for composer item (recursive tree) -->
<ul class="compose-element" template="tpl" tpl-set="compose-element">
    <li class="compose-item" ng-if="isReady">
        <div class="compose-item-line">
            <span class="compose-item-icon" ng-switch="hasChildren()">
                <i class="glyphicon glyphicon-triangle-bottom"
                   ng-switch-when="true"
                   ng-click="collapse($event)"></i>

                <i class="glyphicon glyphicon-triangle-right" ng-switch-default>&nbsp;</i>
            </span>

            <span class="compose-item-label">
                <b ng-click="editKey($event, scope)">{{ !label ? '""' : label }}</b>
                (<a ng-click="editType($event, scope)">{{ !type ? '""' : type }}</a>):
            </span>

            <span class="compose-item-value" ng-switch="jsType()">
                <input type="text"
                       ng-switch-when="string"
                       ng-model="value"
                       ng-change="edit(value)"/>

                <input type="number"
                       step="0.1"
                       ng-switch-when="number"
                       ng-model="value"
                       ng-change="edit(value)"/>

                <input type="checkbox"
                       ng-switch-when="boolean"
                       ng-model="value"
                       ng-change="edit(value)"/>
            </span>

            <button ng-click="removeItem($event, self)">
                <i class="glyphicon glyphicon-trash"></i>
            </button>

            <button ng-if="info" ng-click="addItem($event, self)">
                <i class="glyphicon glyphicon-plus"></i>
            </button>

            <button ng-if="canEdit()" ng-click="editItem($event, self)">
                <i class="glyphicon glyphicon-edit"></i>
            </button>

            <button ng-if="hasUnits" ng-click="addUnit($event, self)">
                <i class="glyphicon glyphicon-indent-left"></i>
            </button>
        </div>

        <div class="compose-item-line" ng-controller="ComposeEditor" ng-init="init(editorData())">
            <span class="compose-edit-key">
                <select>
                    <option ng-repeat="(key, val) in items">{{!val.label ? key : label}}</option>
                </select>
                <input type="text" ng-model="key" ng-if="custom" />
            </span>

            <span class="compose-edit-type">
                <select ng-if="hasTypes()">
                    <option ng-repeat="(key, val) in getTypes()"></option>
                </select>
                <input type="text" ng-model="type"/>
            </span>

            <input type="text" ng-model="value"/>

            <button ng-click="cancel()">
                <i class="glyphicon glyphicon-remove"></i>
            </button>

            <button ng-click="apply()">
                <i class="glyphicon glyphicon-ok"></i>
            </button>

        </div>

        <!-- sub-elements rendering -->
        <span ng-repeat="(key, val) in children track by childValue(key)">
            <template get="compose-element" data="val" controller="ComposeElement"></template>
        </span>
    </li>
</ul>

<div class="container" ng-controller="RootController">
    <template get="compose-element" data="data" controller="ComposeElement"></template>
</div>

</body>
</html>