<!doctype html>
<html>
<head lang="en">
    <meta charset="utf-8">
    <title>JSON Editor UI</title>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" >
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.2/angular.min.js"></script>


    <style>
        .temp-btn {
            float: right;
        }

        #check-btn {
            float: left;
        }

        #container {
            width: 900px;
            margin-left: 10px;
            padding-left: 5px;
            background-color: #f3f6fa;
            background-image: repeating-linear-gradient(180deg, #d9edf7, #d9edf7 30px, #f5f5f5 30px, white 60px);
        }

        #wrapper {
            padding: 0px;
        }

        ul{
            list-style: none;
        }

        li{
            height: 100%;
        }

        li.minimized{
            height: 30px;
            overflow-y: hidden;
        }

        .css-form input.ng-invalid.ng-touched {
            border-color: #FA787E;
        }

        /*.css-form input.ng-valid.ng-touched {*/
        /*border-color: #78FA89;*/
        /*}*/

        input.form-input {
            width: 100px;
            border: none;
            display: inline;
            height: 30px;
            padding: 5px;
            background-color: transparent;
        }

        input.form-control, select.form-control {
            width: 150px;
            display: inline;
            height: 30px;
            padding: 5px;
            background-color: transparent;
        }

        .value-line {
            height: 30px;
        }

        #screen {
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.25);
            position: absolute;
            top: 0;
        }

        #modal {
            width: 33.333%;
            top: 20%;
            left: 33.3333%;
            z-index: 2;
            position: fixed;
        }

        .value-line span {
            line-height: 30px;
        }

        .value-line button {
            box-sizing: border-box;
            height: 30px;
            line-height: 26px;
            border-color: transparent;
            background-color: transparent;
        }

        button.add-btn {
            margin-right: 5px;
        }

        button.unit-btn {
            margin-right: 5px;
        }

        button.remove-btn {
            margin-right: 0px;
        }

    </style>

    <script type="text/javascript">
        angular
                .module('JSONEditor', [])
                .controller('JSONEditor', JSONEditor)
                .directive('template', template);

        /**
         * THE CONTROLLER
         */

        JSONEditor.$inject = ["$scope", "$http"];
        function JSONEditor($scope, $http){

            /**
             * ---------- VARIABLES DECLARATION -----------
             */
            var _ANY_ = "*"; // any base type
            var _UP_ = ">"; // unit prefix
            var _AP_ = "@"; // argument prefix
            var _OP_ = ":"; // output prefix
            var _PS_ = "."; // path separator

            var json = {};
            var jsonType = "Test";
            var complexTypes = {};
            var DBTypes = {};
            var units = {};

            /**
             * Base types declaration and validation
             */
            var baseTypes = {
                "string":   function(val) {
                    if(val == undefined){
                        val = "";
                    }
                    return val.toString();
                },
                "int":      function(val) {
                    if(val == undefined){
                        val = 0;
                    }
                    return parseInt(val);
                },
                "float":    function(val) {
                    if(val == undefined){
                        val = 0;
                    }
                    return parseFloat(val);
                },
                "boolean":  function(val) {
                    return val ? true : false;
                },
                "array":    function(val) {
                    if (!Array.isArray(val)) {
                        val = [];
                    }
                    return val;
                },
                "object":   function(val) {
                    if (baseTypes.getTypeOf(val) != "object") {
                        val = {};
                    }
                    return val;
                }
            };

            $scope.json = json;
            $scope.jsonType = jsonType;
            $scope.complexTypes = complexTypes;
            $scope.DBTypes = DBTypes;
            $scope.units = units;
            $scope.baseTypes = baseTypes;

            $scope.isDialogHidden = true;

            /**
             *  requests when app starts
             *
             *  requestDBTypesInfo
             *  requestUnitsForTypeAny
             */

            /**
             * help functions
             *
             * pathToArray
             * replaceBrackets
             */
            $scope.isArrayType = isArrayType;
            $scope.isInArray = isInArray;

            /**
             * applied to complex types and units
             */
            $scope.getItemInfo  = getItemInfo;
            $scope.getItemType = getItemType;
            $scope.getItemLabel = getItemLabel;
            $scope.getKeyInfo = getKeyInfo;

            /**
             * applied to complex types
             */
            complexTypes.complexTypesDict = {};
            complexTypes.isComplexType = isComplexType;
            complexTypes.getComplexTypes = getComplexTypes;
            complexTypes.requestTypeInfo = requestTypeInfo;

            /**
             * applied to DB types (requested all)
             */
            DBTypes.DBTypesDict = {};
            DBTypes.isDBType = isDBType;
            DBTypes.getDBTypes = getDBTypes;

            /**
             * applied to Units
             */
            units.unitsDict = {};
            units.isUnit = isUnit;
            units.isArgument = isArgument;
            units.isOutput = isOutput;
            units.addUP = addUP;
            units.removeUP = removeUP;
            units.hasUnits = hasUnits;
            units.getUnits = getUnits;
            units.getUnitArgs = getUnitArgs;

            /**
             * applied to Base types
             */
            baseTypes.isBaseType = isBaseType;
            baseTypes.isEmpty = isEmpty;
            baseTypes.getBaseTypes = getBaseTypes;
            baseTypes.getTypeOf = getTypeOf;
            baseTypes.convertToValue = convertToValue;

            /**
             * applied to JSON
             */
            $scope.getItem = getItem;
            $scope.getJsonItem = function(path) {
                return getItem(path, $scope.json)
            };
            $scope.addItem = addItem;
            $scope.addJsonItem = function(path, key, type, val) {
                return addItem($scope.json, path, key, type, val);
            };
            $scope.removeItem = removeItem;
            $scope.removeJsonItem = function(path, key, val){
                return removeItem($scope.json, path, key, val);
            };
            $scope.editItem = editItem;

            /**
             * applied to dialog
             *
             * +showDialog
             */
            $scope.addItemDialog = addItemDialog;
            $scope.getPossibleKeys = getPossibleKeys;
            $scope.getPossibleUnitKeys = getPossibleUnitKeys;
            $scope.getPossibleUnits = getPossibleUnits;

            /**
             * (applied to)/checks rule
             */
            $scope.checkAccordance = checkAccordance;

            /**
             *----------------- FUNCTIONS -------------------
             */

            function isUnit(key) {
                if(key == undefined){
                    return false;
                }
                return key.toString().startsWith(_UP_);
            }

            function isArgument(key) {
                if(key == undefined){
                    return false;
                }
                return key.toString().startsWith(_AP_);
            }

            function isOutput(key) {
                if(key == undefined){
                    return false;
                }
                return key.toString().startsWith(_OP_);
            }

            function pathToArray(path) {
                return path.toString()
                        .replace(new RegExp("^[" + _PS_ + "]+"), "")
                        .replace(new RegExp("[" + _PS_ + "]+$"), "")
                        .split(_PS_);
            }

            /**
             * Makes HTTP request to get information about db types
             */
            function requestDBTypesInfo() {
                $http({
                    method : "GET",
                    url : "http://localhost:3000/composer/db-types"
                }).then(function(response){
                    DBTypes.DBTypesDict = response.data.result;
                }, function(){
                    return null;
                });
            }
            requestDBTypesInfo();

            /**
             * Makes HTTP request in order to resolve complex type information
             */
            function requestTypeInfo(type, handler) {
                var promise = $http({
                    method : "GET",
                    url : "http://localhost:3000/composer/type/" + type
                });

                promise.then(function (response){
                    var res = response.data.result;
                    complexTypes.complexTypesDict[type] = res;
                    return res;
                }, function(){
                    return null;
                }).then(function (res){
                    var types = [];
                    for(var key in res){
                        var itemType = getItemType(res[key]);
                        if(units.unitsDict[itemType] == undefined &&
                                types.indexOf(itemType) == -1 &&
                                !isArrayType(itemType)) {
                            types.push(itemType);
                        }
                    }
                    //types.join(",");

                    if(types != []){
                        var promise = $http({
                            method : "GET",
                            url : "http://localhost:3000/composer/units/" + types
                        });

                        promise.then(function(response) {
                            var types = response.data.result;
                            for(var type in types){
                                units.unitsDict[type] = types[type];
                            }
                            if(handler != undefined){
                                try {
                                    handler();
                                } catch(e) {}
                            }
                        });
                    } else if(handler != undefined) {
                        try {
                            handler();
                        } catch(e) {}
                    }

                });

                return promise;
            }

            /**
             * Returns array of "base" types names
             */
            function getBaseTypes() {
                return Object.keys(baseTypes);
            }

            /**
             * Returns array of "db" types names
             */
            function getDBTypes() {
                return Object.keys(DBTypes.DBTypesDict);
            }

            /**
             * Returns array of "complex" types names
             */
            function getComplexTypes() {
                return Object.keys(complexTypes.complexTypesDict);
            }

            /**
             * Returns true if given type is kind of "base" type
             */
            function isBaseType(type) {
                return isInArray(type, baseTypes.getBaseTypes());
            }

            /**
             * Returns true if given type is kind of "db" type
             */
            function isDBType(type) {
                return isInArray(type, DBTypes.getDBTypes());
            }

            /**
             * Returns true if given type is kind of "complex" type
             */
            function isComplexType(type) {
                return isInArray(type, complexTypes.getComplexTypes())
            }

            /**
             * Returns simple type of the given object
             */
            function getTypeOf(value) {
                if(value === null) {
                    return "null";
                }
                if(Array.isArray(value)) {
                    return "array";
                }

                return (typeof value).toLowerCase();
            }

            /**
             * Converts the given value to a specified type
             * (returns original value for unknown types)
             */
            function convertToValue(type, val) {
                if(type == undefined) {
                    return null;
                }
                //type in base types
                if(type in baseTypes) {
                    val = baseTypes[type](val);
                } else {
                    if(isArrayType(type)){
                        type = "array";
                    } else {
                        type = "object";
                    }
                    val = baseTypes.convertToValue(type, val);
                }

                return val;
            }

            /**
             * Check if complex type consist of array items
             * (the same type for each item)
             */
            function isArrayType(type) {
                if (type == undefined) {
                    return false;
                }

                if(baseTypes.getTypeOf(type) == "object"){
                    type = type.type;
                }

                if(type.indexOf("[]") == 0 || type == "array") {
                    return true;
                }
                return false;
            }

            /**
             * reoalce Brackets in type
             */
            function replaceBrackets(type) {
                if(baseTypes.getTypeOf(type) == "object"){
                    return type;
                } else {
                    return  type.replace("[]", "");
                }
            }

            /**
             * Returns true if value type equals one of given types
             */
            function isInArray(valueType, types) {
                return types.length != 0 && types.indexOf(valueType) != -1;
            }

            /**
             * Returns type by path
             */
            function getItemInfo(path, val, type) {
                if (type == undefined) {
                    type = jsonType;
                }

                // checking if we are reached end of path

                if(path == undefined || path == ""){
                    return type;
                }

                path = pathToArray(path);

                // arrays have the same type for each item
                var typeIsArray = isArrayType(type);
                type = replaceBrackets(type);

                var typeItems = undefined;
                var path0 = path.shift();
                var pathIsUnit = units.isUnit(path0);

                if(!pathIsUnit && complexTypes.isComplexType(type)) {
                    typeItems = complexTypes.complexTypesDict[type];
                } else {
                    path0 = units.removeUP(path0);
                    typeItems = Object.assign({}, units.unitsDict[type]);
                    if(baseTypes.isBaseType(type)){
                        Object.assign(typeItems, units.unitsDict[_ANY_]);
                    }
                }

                if(typeItems == undefined){
                    return null;
                }

                if(typeof typeItems == "object") {
                    if (path0 in typeItems) {
                        if(!pathIsUnit) {
                            type = typeItems[path0];
                        }
                    } else if(!typeIsArray) {
                        return null;
                    }

                    if (path.length > 0) {
                        return getItemInfo(path.join(_PS_), val, getItemType(type));
                    }

                    if(pathIsUnit) {
                        type = typeItems[path0];
                    }
                    return type;
                }

                return baseTypes.getTypeOf(val);
            }

            /**
             * Returns type for Complex type
             */
            function getItemType(typeInfo) {
                if(baseTypes.getTypeOf(typeInfo) == "object"){
                    var type = typeInfo.type;
                    if(DBTypes.isDBType(type)){
                        return DBTypes.DBTypesDict[type].type;
                    }
                    return type;
                }
                return typeInfo;
            }

            /**
             * Returns label for Complex type
             */
            function getItemLabel(typeInfo) {
                if(baseTypes.getTypeOf(typeInfo) == "object"){
                    return typeInfo.label;
                }
                return typeInfo;
            }

            /**
             * Returns the given object value for a specified path
             */
            function getItem(path, object) {

                if (object == undefined) {
                    object = json;
                }

                var type = baseTypes.getTypeOf(object)
                if (type != "object" && type != "array") {
                    return null
                }

                if(path == undefined || path == ""){
                    return object;
                }
                var path = pathToArray(path);

                if (path[0] in object) {
                    object = object[path.shift()];
                } else {
                    return null
                }

                if (path.length > 0) {
                    return getItem(path.join(_PS_), object);
                }

                return object;
            }

            /**
             * Updates the given root object with a new item for a specified path
             */
            function addItem(root, path, key, type, val) {
                if(key == undefined) {
                    alert("please enter the key");
                    $scope.isDialogHidden = false;
                    return;
                }

                var workingItem = getItem(path, root);

                if (baseTypes.getTypeOf(workingItem) != "object" && (units.isUnit(key)) || units.isArgument(key) || units.isOutput(key)) {
                    var newType = "object";

                    var parentPath = pathToArray(path);
                    var workingItemKey = parentPath.pop();
                    parentPath = parentPath.join(_PS_);

                    //editItem(parentPath, workingItemKey, newType, {"": workingItem});
                    editItem(parentPath, workingItemKey, newType, {});
                    workingItem = getItem(path, root);
                }

                val = baseTypes.convertToValue(type, val);

                if(key in workingItem){
                    alert("this key already exist");
                    $scope.isDialogHidden = false;
                } else {
                    workingItem[key] = val;
                }

            }

            /**
             * Removes the given object value for a specified path
             */
            function removeItem(object, path, key, val) {
                var item = getItem(path, object);
                var type = baseTypes.getTypeOf(item);
                if (type == "object") {
                    delete(item[key]);
//                        if(isUnit(key)) {
//                            var parentPath = pathToArray(path);
//                            var workingItemKey = parentPath.pop();
//                            var newType = getItemType(getItemInfo(path, val));
//                            editItem(parentPath, workingItemKey, newType, val);
//                        }
                } else if (type == "array") {
                    item.splice(key,1);
                }
            }

            /**
             * Edits the given object value by specified path
             */
            function editItem(path, key, type, val, flag) {
                if (path == undefined) {
                    path = "";
                }

                var item = $scope.getJsonItem(path);

                if (type != "object"){
                    val = baseTypes.convertToValue(type, val);
                }
                // TODO: explain ???
                //if(!flag){
                item[key] = val;
                //}
                return val;
            }

            /**
             * Show dialog - opens the items creation dialog
             */
            function addItemDialog (path, key, flag){
                // Initialization / Validation
                // ---------------------------
                if (path == undefined){
                    path = "";
                }

                if(key != undefined) {
                    path = path + _PS_ + key;
                } else {
                    key = "";
                }

                var pathToParent, index = path.indexOf(_UP_);
                if(index != -1){
                    pathToParent = path.substring(0, index);
                } else {
                    pathToParent = path;
                }

                var parentType = getItemType(getItemInfo(pathToParent));
                if(baseTypes.getTypeOf(parentType) == "object"){
                    parentType = parentType.type;
                }

                var parentItem = getItem(path);

                var showDialog = function() {
                    // Dialog variables preparations before show
                    // -----------------------------------------

                    var dialogObject = {
                        showKey: true,
                        showInputKey: false,
                        showSelectKey: true,
                        showInputType: true,
                        showSelectType: false,
                        unitFlag: false
                    };

                    if (isArrayType(parentType)) {
                        dialogObject.showKey = false;
                        dialogObject.key = parentItem.length;
                        if (parentType == "[]Any" || parentType == "array") {
                            dialogObject.baseTypes = baseTypes.getBaseTypes();
                            dialogObject.showSelectType = true;
                            dialogObject.showInputType = false;
                        } else {
                            dialogObject.type = replaceBrackets(parentType);
                        }
                    } else if (parentType == "object") {
                        dialogObject.showSelectKey = false;
                        dialogObject.showInputKey = true;
                        dialogObject.showSelectType = true;
                        dialogObject.showInputType = false;
                        dialogObject.baseTypes = baseTypes.getBaseTypes();
                    }

                    if(units.isUnit(key)) {
                        if(flag == "unit") {
                            dialogObject.unitFlag = true;
                            dialogObject.possibleKeys = getPossibleUnits(parentType);
                        } else {
                            dialogObject.possibleKeys = getPossibleUnitKeys(parentType, key);
                        }
                    } else {
                        if(flag == "unit") {
                            dialogObject.unitFlag = true;
                            dialogObject.possibleKeys = getPossibleUnits(parentType);
                        } else {
                            dialogObject.possibleKeys = getPossibleKeys(parentType);
                        }
                    }

                    dialogObject.path = path;

                    // Showing dialog to user
                    // ----------------------
                    $scope.dialog = dialogObject;
                    if($scope.isDialogHidden){
                        $scope.isDialogHidden = false;
                    }
                };

                if(!units.isUnit(key) && !units.isArgument(key) && !units.isOutput(key)) {
                    if (!isArrayType(parentType) && !baseTypes.isBaseType(parentType) && parentType != _ANY_) {
                        if (!complexTypes.isComplexType(parentType)) {
                            complexTypes.requestTypeInfo(replaceBrackets(parentType), function () {
                                showDialog();
                            });
                        } else {
                            showDialog();
                        }
                    } else {
                        showDialog();
                    }
                } else {
                    showDialog();
                }
            }

            /**
             * Makes HTTP request to get information about units
             */
            function requestUnitsForTypeAny() {
                $http({
                    method: "GET",
                    url: "http://localhost:3000/composer/units/*"
                }).then(function(response){
                    units.unitsDict = response.data.result;
                });
            }
            requestUnitsForTypeAny();

            /**
             * Adds unit prefix
             */
            function addUP(unitName) {
                return _UP_ + unitName;
            }

            /**
             * Removes unit prefix
             */
            function removeUP(unitName) {
                return unitName.replace(_UP_, "");;
            }

            /**
             * Checks if to type can be applied units
             */
            function hasUnits(type) {
                return units.unitsDict[type] != undefined && (!baseTypes.isEmpty(units.unitsDict[type]) || baseTypes.isBaseType(type));
            }

            /**
             * Checks object on emptiness
             */
            function isEmpty(obj) {
                for(var prop in obj) {
                    if(prop)
                        return false;
                }

                return true;
            }

            /**
             * Returns keys by type
             */
            function getPossibleKeys(type) {

                if(type == undefined){
                    return null;
                }

                if(type == "array"){
                    return Object.keys(baseTypes);
                }

                type = replaceBrackets(type);
                var keys = [];
                if (complexTypes.isComplexType(type)) {
                    var item = complexTypes.complexTypesDict[type];
                    for(var key in item){
                        if(key != ""){
                            var v = {};
                            v.key = key;
                            v.label = "(" + key + ") - " + getItemLabel(item[key]);
                            keys.push(v);
                        }
                    }
                } else {
                    return null;
                }

                return keys;
            }

            /**
             * Returns keys by type
             */
            function getPossibleUnitKeys(type, unitName) {
                var keys = [];
                unitName = removeUP(unitName);

                keys = keys.concat(units.getUnitArgs(type, unitName));
                if(baseTypes.isBaseType(type)){
                    keys = keys.concat(units.getUnitArgs(_ANY_, unitName));
                }

                return keys;
            }

            function getUnitArgs(type, unitName){
                var keys = [];
                var unit = units.unitsDict[type][unitName];
                if(unit) {
                    for (var key in unit) {
                        if (key != _UP_) {
                            var v = {};
                            v.key = key;
                            if(units.isArgument(key)){
                                v.label = "\<arg\> - (" + key + ")";
                            } else if(key == "") {
                                v.key = _OP_;
                                v.label = "\<out\> - (" + _OP_ + ")";
                            } else {
                                v.label = "(" + key + ")";
                            }
                            keys.push(v);
                        }
                    }
                }

                return keys;
            }

            /**
             * Returns unitss by type
             */
            function getPossibleUnits(type) {
                if(type == undefined){
                    return null;
                }

                type = replaceBrackets(type);
                var keys = [];
                var typeUnits;

                if (units.hasUnits(type)) {
                    typeUnits = units.unitsDict[type];
                    keys = keys.concat(units.getUnits(typeUnits));
                }
                if(baseTypes.isBaseType(type)){
                    typeUnits = units.unitsDict[_ANY_];
                    keys = keys.concat(units.getUnits(typeUnits));
                }

                return keys;
            }

            function getUnits(typeUnits) {
                var keys = [];
                for(var unitName in typeUnits){
                    var unitInfo = typeUnits[unitName][_UP_];
                    var v = {};
                    v.key = units.addUP(unitName);
                    v.label = "(" + unitName + ") - " + getItemLabel(unitInfo);
                    keys.push(v);
                }

                return keys;
            }
            /**
             * Returns  type and label for corresponding complex type by path and key
             */
            function getKeyInfo(path, key, val) {
                if(path == undefined){
                    path = "";
                }

                var pathToParent, info = {};

                var index = path.indexOf(_UP_);
                if(index != -1){
                    pathToParent = path.substring(0, index);
                } else {
                    pathToParent = path;
                }

                var grandParentItemInfo = getItemInfo(pathToParent, val);
                var parentItemInfo = getItemInfo(path, val);
                var itemInfo = getItemInfo(path + '.' + key, val);


                if(units.isUnit(key)) {
                    info.label = "(" + key + ") - " + getItemLabel(itemInfo[_UP_]);
                    info.type = getItemType(grandParentItemInfo);
                    //info.type = "unit";
                } else if (units.isArgument(key)) {
                    info.label = "\<arg\> - (" + key + ")";
                    info.type = getItemType(parentItemInfo[_AP_]);
                    if(info.type == _ANY_){
                        info.type = getItemType(grandParentItemInfo);
                    }
                } else if (units.isOutput(key)) {
                    info.label = "\<out\> - (" + key + ")"
                    info.type = getItemType(parentItemInfo[""]);
                    if(info.type == _ANY_){
                        info.type = getItemType(grandParentItemInfo);
                    }
                } else {
                    info.label = "(" + key + ") - " + getItemLabel(itemInfo);
                    info.type = getItemType(itemInfo);
                }

                return info;
            }

            /**
             * checks accordance between input and rule
             */
            function checkAccordance(json){
                var promise = $http({
                    method: "POST",
                    data: json,
                    url: "http://localhost:3000/composer/check"
                });

                promise.then(function(response){
                            alert(response.data.result);
                        },
                        function(){
                            return null;
                        });
            }

            /**
             * hides/shows list view
             */
            $scope.roll = function(e){
                e.stopPropagation();

                var target = angular.element(e.target);
                target.toggleClass('glyphicon-chevron-right glyphicon-chevron-down');

                while(target.parent()){
                    if (target.parent().prop('tagName') === 'LI'){
                        target.parent().toggleClass('minimized');
                        return
                    } else target = target.parent();
                }

                console.log(target.prop('tagName'));

            };
        }

        /**
         * THE <template> DIRECTIVE
         */

        template.$inject = ["$compile"];
        function template($compile) {
            return {
                restrict: 'EA',
                scope: true,
                compile: function(element, attributes) {

                    /* initializing directive related variables */
                    var templateIsTag = false;
                    var templateName = null;
                    var templateAttributes = {};

                    if (element[0].tagName.toLowerCase() == this.name.toLowerCase()) {
                        templateIsTag = true;
                    }

                    /* template attributes filtering */
                    if (templateIsTag) {
                        /* case 1: directive usage as a tag - all attributes related */
                        for(var attribute in attributes.$attr) {
                            var attr = attribute.replace(/^(data-|x-)/, "").toLowerCase();
                            templateAttributes[attr] = attributes[attribute];
                        }

                    } else {
                        /* case 2: directive usage as an attribute - attribute prefix filtering*/
                        var templatePrefix = "tp";
                        for (var loop=true; loop; loop=!loop) {
                            for(var attribute in  attributes.$attr) {
                                var attr = attribute.replace(/^(data-|x-)/, "").toLowerCase();

                                /* non default prefix specified, we should repeat scan for that case (as attributes order is not strict) */
                                if (attr == "template" && attributes[attribute] != "") {
                                    templatePrefix = attributes[attribute];

                                    delete attributes.$attr[attribute];
                                    element.removeAttr(attribute);

                                    loop = false;
                                }

                                /* grabbing template related attributes and removing them from element */
                                if (attr.startsWith(templatePrefix)) {
                                    attr = attr.slice(templatePrefix.length);

                                    templateAttributes[attr] = attributes[attribute];
                                    delete attributes.$attr[attribute];
                                    element.removeAttr(attribute);
                                }
                            }
                        }
                    }

                    /* template "set" operation specified */
                    if ("set" in templateAttributes) {
                        var templateName = templateAttributes["set"];
                        delete templateAttributes["set"]

                        if (typeof angular.templates == 'undefined') {
                            angular.templates = {};
                        }

                        /* angular scope and $compile operations requires top element */
                        if (templateIsTag) {
                            angular.templates[templateName] = "<span>" + element.html() + "</span>";
                        } else {
                            angular.templates[templateName] = element[0].outerHTML;
                        }
                    }

                    /* template "get" operation specified */
                    if ("get" in templateAttributes) {
                        templateName = templateAttributes["get"];
                        delete templateAttributes["get"]
                    } else {
                        templateName = null;
                    }

                    /* directive's "link" function */
                    return function(scope, element, attributes) {

                        var result = '';
                        if (templateName != null && templateName != '') {
                            /* looking for a stored template HTML */
                            var templateHTML = '';
                            if (typeof angular.templates != 'undefined' &&
                                    typeof angular.templates[templateName] != 'undefined') {

                                templateHTML = angular.templates[templateName];
                            }

                            /* taking subject to which new scope will be applied */
                            var templateElement = angular.element();
                            if (templateIsTag) {
                                if (templateHTML != '') {
                                    templateElement = angular.element(templateHTML)
                                }
                            } else {
                                templateElement = element.append(templateHTML);
                            }

                            /* making new scope */
                            var templateScope = scope.$new(false, scope);
                            for (var attr in templateAttributes) {
                                val = templateAttributes[attr];
                                try {
                                    val = val.replace(/^\s*\{\{\s*/, "").replace(/\s*\}\}\s*$/, "");
                                    val = scope.$eval(val);
                                } catch (e) {
                                    console.log("error", val);
                                }
                                templateScope[attr] = val;
                            }

                            /* applying new scope to the subject */
                            result = $compile(templateElement)(templateScope);
                        }
                        element.replaceWith(result);

                    }
                }
            }
        }
    </script>
</head>
<body ng-app="JSONEditor" ng-controller="JSONEditor">

<!-- Template for tree item rendering -->

<ul template="tpl" tpl-set="tree-item" ng-if="baseTypes.getTypeOf(item) == 'object' || baseTypes.getTypeOf(item) == 'array'" >

    <!-- items loop -->
    <li ng-repeat="(key, val) in item track by [key,val,item]">
        <!-- http://stackoverflow.com/questions/16796341/set-angular-scope-variable-in-markup -->
        {{itemInfo = getKeyInfo(path, key, val);""}}
        {{itemType = itemInfo.type;""}}
        {{valueType = baseTypes.getTypeOf(val);""}}
        <div class="value-line">
                    <span>
                        <i ng-if="valueType == 'object' || valueType == 'array'" class='glyphicon glyphicon-chevron-down' ng-click="roll($event)"></i>
                        <b>{{itemInfo.label}}</b>
                    </span>
            <!--({{itemType}})-->
            {{isUnit = units.isUnit(key);""}}
            <span ng-if="units.isUnit(key)">(unit)</span>
            <span ng-if="!units.isUnit(key)">({{itemType}})</span>

            <!-- string value -->
                    <span ng-if="valueType == 'string'">
                        <input class="form-input" type="text" ng-model="val" ng-change="val = editItem(path, key, itemType, val)"/>
                    </span>

            <!-- number value -->
                    <span ng-if="valueType == 'number'">
                        <input class="form-input" type="number" step="0.1" ng-model="val" ng-change="val = editItem(path, key, itemType, val)"/>
                    </span>

            <!-- boolean value -->
                    <span ng-if="valueType == 'boolean'">
                        <input class="form-input-checkbox" type="checkbox" ng-model="val" ng-change="val = editItem(path, key, itemType, val)"/>
                    </span>

            <!-- remove button -->
            <button  class="temp-btn remove-btn" ng-click="removeJsonItem(path, key, val)"><i class="glyphicon glyphicon-trash"></i></button>

            <!-- add item button -->
            <button ng-if="(itemType == 'object' || itemType == 'array' || units.isUnit(key) || !baseTypes.isBaseType(itemType)) && (!units.isArgument(key) && !units.isOutput(key))" class="trigger-modal temp-btn add-btn" ng-click="addItemDialog(path, key)"><i class="glyphicon glyphicon-plus"></i></button>

            <!-- add unit button -->
            <button ng-if="units.hasUnits(itemType) && !units.isArgument(key) && !units.isOutput(key)" class="trigger-modal temp-btn unit-btn" ng-click="addItemDialog(path, key, 'unit')"><i class="glyphicon glyphicon-indent-left"></i></button>

        </div>

        <!-- recursive template execution for a value -->
        <template get="tree-item" item="val" key="key" path="{{path + '.' + key}}"></template>
    </li>
</ul>

<!-- JSON Representation -->
<pre>{{json |json}}</pre>

<!-- JSON Editor -->
<div id="container">
    <ul id="wrapper">
        <li>
            <div class="value-line">
                        <span>
                            <i ng-if="!isInArray(jsonType, ['string', 'boolean', 'int', 'float'])" class='glyphicon glyphicon-chevron-down' ng-click="roll($event)"></i>
                            ({{jsonType}})
                        </span>

                <!--add item button-->
                <button class="trigger-modal temp-btn" style="margin-right: 35px;" ng-if="!isInArray(jsonType, ['string', 'boolean', 'number'])" ng-click="addItemDialog(path, key)"><i class="glyphicon glyphicon-plus"></i></button>
            </div>

            <template get="tree-item" item="json" key="" path=""></template>
        </li>
    </ul>
    <button id="check-btn" class="temp-btn" ng-click="checkAccordance(json)">Check</button>
</div>

<!-- Create Item Dialog -->
<!--<div id="screen" ng-hide="isDialogHidden"></div>-->
<div id="modal" class="panel panel-default" ng-hide="isDialogHidden">
    <div class="panel-heading">
        <p>add to <b>{{dialog.path}}</b></p>
    </div>
    <div class="panel-body">
        <form novalidate name="addItem" class="css-form">
            <div novalidate class="form-group css-form">

                <!-- key input -->
                <div ng-show="dialog.showKey">
                    <label ng-if="dialog.unitFlag">Unit:</label>
                    {{unitFlag}}
                    <label ng-if="!dialog.unitFlag">Key:</label>
                    <input  type="text" ng-show="dialog.showInputKey" ng-model="dialog.key" class="form-control" required/>
                    <select ng-show="dialog.showSelectKey" ng-options="option.label for option in dialog.possibleKeys" ng-model="info" ng-change="dialog.type = getKeyInfo(dialog.path, info.key).type" class="form-control" required></select>
                </div>

                <!-- type selector -->
                <div>
                    <br>
                    <label>Type:</label>
                    <input ng-show="dialog.showInputType" type="text" ng-model="dialog.type" class="form-control" readonly/>
                    <select ng-show="dialog.showSelectType" ng-options="option for option in dialog.baseTypes" ng-model="dialog.type" class="form-control" required></select>
                </div>

                <!-- value input -->
                <div ng-switch="dialog.type">
                    <br>
                    <label>Value:</label>

                    <!-- string value -->
                            <span ng-switch-when="string">
                                <input class="form-control" type="text" ng-model="dialog.val" required/>
                            </span>

                    <!-- number value -->
                            <span ng-switch-when="int">
                                <input class="form-control" type="number" ng-model="dialog.val" required/>
                            </span>

                    <!-- number value -->
                            <span ng-switch-when="float">
                                <input class="form-control" type="number" ng-model="dialog.val" required/>
                            </span>

                    <!--boolean value -->
                            <span ng-switch-when="boolean">
                                <input class="form-input-checkbox" type="checkbox" ng-model="dialog.val"/>
                            </span>

                    <!-- default value -->
                            <span ng-switch-default>
                                N/A
                            </span>
                </div>

            </div>
        </form>
    </div>

    <!-- Actions -->
    <div class="panel-footer">
        {{currKey = info.key ? info.key : dialog.key; ""}}
        <button class="btn btn-default" ng-click="isDialogHidden=true; addJsonItem(dialog.path, currKey, dialog.type, dialog.val)">Add</button>
        <button class="btn btn-default" ng-click="isDialogHidden=true;">Cancel</button>
    </div>
</div>

</body>

</html>
